

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>CPP – Notes on The Cherno C++ Videos &mdash; MiscBeginnerSC 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="DS and Algo" href="DS%20and%20Algo.html" />
    <link rel="prev" title="&lt;no title&gt;" href="C%2B%2B.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> MiscBeginnerSC
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Misc</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Backprop.html">Backpropagation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Bokeh.html">Bokeh</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">CPP – Notes on The Cherno C++ Videos</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#1.-Welcome-to-C++">1. Welcome to C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#2.-How-to-Setup-C++-on-Windows">2. How to Setup C++ on Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#3.-How-to-Setup-C++-on-Mac">3. How to Setup C++ on Mac</a></li>
<li class="toctree-l2"><a class="reference internal" href="#4.-How-to-Setup-C++-on-Linux">4. How to Setup C++ on Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="#5.-How-C++-Works">5. How C++ Works</a></li>
<li class="toctree-l2"><a class="reference internal" href="#6.-How-the-C++-Compiler-Works">6. How the C++ Compiler Works</a></li>
<li class="toctree-l2"><a class="reference internal" href="#7.-How-the-C++-Linker-Works">7. How the C++ Linker Works</a></li>
<li class="toctree-l2"><a class="reference internal" href="#8.-Variables-in-C++">8. Variables in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#9.-Functions-in-C++">9. Functions in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#10.-C++-Header-Files">10. C++ Header Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#11.-How-to-DEBUG-C++-in-VISUAL-STUDIO">11. How to DEBUG C++ in VISUAL STUDIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#12.-CONDITIONS-and-BRANCHES-in-C++-(if-statements)">12. CONDITIONS and BRANCHES in C++ (if statements)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#13.-BEST-Visual-Studio-Setup-for-C++-Projects!">13. BEST Visual Studio Setup for C++ Projects!</a></li>
<li class="toctree-l2"><a class="reference internal" href="#14.-Loops-in-C++-(for-loops,-while-loops)">14. Loops in C++ (for loops, while loops)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#15.-Control-Flow-in-C++-(continue,-break,-return)">15. Control Flow in C++ (continue, break, return)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#16.-POINTERS-in-C++">16. POINTERS in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#17.-REFERENCES-in-C++">17. REFERENCES in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#18.-CLASSES-in-C++">18. CLASSES in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#19.-CLASSES-vs-STRUCTS-in-C++">19. CLASSES vs STRUCTS in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#20.-How-to-Write-a-C++-Class">20. How to Write a C++ Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#21.-Static-in-C++">21. Static in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#22.-Static-for-Classes-and-Structs-in-C++">22. Static for Classes and Structs in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#23.-Local-Static-in-C++">23. Local Static in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#24.-ENUMS-in-C++">24. ENUMS in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#25.-Constructors-in-C++">25. Constructors in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#26.-Destructors-in-C++">26. Destructors in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#27.-Inheritance-in-C++">27. Inheritance in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#28.-Virtual-Functions-in-C++">28. Virtual Functions in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#28.5-Vtable">28.5 Vtable</a></li>
<li class="toctree-l2"><a class="reference internal" href="#29.-Interfaces-in-C++-(Pure-Virtual-Functions)">29. Interfaces in C++ (Pure Virtual Functions)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#30.-Visibility-in-C++">30. Visibility in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#31.-Arrays-in-C++">31. Arrays in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#32.-How-Strings-Work-in-C++-(and-how-to-use-them)">32. How Strings Work in C++ (and how to use them)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#33.-String-Literals-in-C++">33. String Literals in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#34.-CONST-in-C++">34. CONST in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#35.-The-Mutable-Keyword-in-C++">35. The Mutable Keyword in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#36.-Member-Initializer-Lists-in-C++-(Constructor-Initializer-List)">36. Member Initializer Lists in C++ (Constructor Initializer List)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#37.-Ternary-Operators-in-C++-(Conditional-Assignment)">37. Ternary Operators in C++ (Conditional Assignment)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#38.-How-to-CREATE/INSTANTIATE-OBJECTS-in-C++">38. How to CREATE/INSTANTIATE OBJECTS in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#39.-The-NEW-Keyword-in-C++">39. The NEW Keyword in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#40.-Implicit-Conversion-and-the-Explicit-Keyword-in-C++">40. Implicit Conversion and the Explicit Keyword in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#41.-OPERATORS-and-OPERATOR-OVERLOADING-in-C++">41. OPERATORS and OPERATOR OVERLOADING in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#42.-The-“this”-keyword-in-C++">42. The “this” keyword in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#43.-Object-Lifetime-in-C++-(Stack/Scope-Lifetimes)">43. Object Lifetime in C++ (Stack/Scope Lifetimes)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#44.-SMART-POINTERS-in-C++-(std::unique_ptr,-std::shared_ptr,-std::weak_ptr)">44. SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#45.-Copying-and-Copy-Constructors-in-C++">45. Copying and Copy Constructors in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#46.-The-Arrow-Operator-in-C++">46. The Arrow Operator in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#47.-Dynamic-Arrays-in-C++-(std::vector)">47. Dynamic Arrays in C++ (std::vector)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#48.-Optimizing-the-usage-of-std::vector-in-C++">48. Optimizing the usage of std::vector in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#49.-Using-Libraries-in-C++-(Static-Linking)">49. Using Libraries in C++ (Static Linking)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#50.-Using-Dynamic-Libraries-in-C++">50. Using Dynamic Libraries in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#51.-Making-and-Working-with-Libraries-in-C++-(Multiple-Projects-in-Visual-Studio)">51. Making and Working with Libraries in C++ (Multiple Projects in Visual Studio)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#52.-How-to-Deal-with-Multiple-Return-Values-in-C++">52. How to Deal with Multiple Return Values in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#53.-Templates-in-C++">53. Templates in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#54.-Stack-vs-Heap-Memory-in-C++">54. Stack vs Heap Memory in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#55.-Macros-in-C++">55. Macros in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#56.-The-“auto”-keyword-in-C++">56. The “auto” keyword in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#57.-Static-Arrays-in-C++-(std::array)">57. Static Arrays in C++ (std::array)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#58.-Function-Pointers-in-C++">58. Function Pointers in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#59.-Lambdas-in-C++">59. Lambdas in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#60.-Why-I-don’t-“using-namespace-std”">60. Why I don’t “using namespace std”</a></li>
<li class="toctree-l2"><a class="reference internal" href="#61.-Namespaces-in-C++">61. Namespaces in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#62.-Threads-in-C++">62. Threads in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#63.-Timing-in-C++">63. Timing in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#64.-Multidimensional-Arrays-in-C++-(2D-arrays)">64. Multidimensional Arrays in C++ (2D arrays)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#65.-Sorting-in-C++">65. Sorting in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#66.-Type-Punning-in-C++">66. Type Punning in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#67.-Unions-in-C++">67. Unions in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#68.-Virtual-Destructors-in-C++">68. Virtual Destructors in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#69.-Casting-in-C++">69. Casting in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#70.-Conditional-and-Action-Breakpoints-in-C++">70. Conditional and Action Breakpoints in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#71.-Safety-in-modern-C++-and-how-to-teach-it">71. Safety in modern C++ and how to teach it</a></li>
<li class="toctree-l2"><a class="reference internal" href="#72.-Precompiled-Headers-in-C++">72. Precompiled Headers in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#73.-Dynamic-Casting-in-C++">73. Dynamic Casting in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#74.-BENCHMARKING-in-C++-(how-to-measure-performance)">74. BENCHMARKING in C++ (how to measure performance)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#75.-STRUCTURED-BINDINGS-in-C++">75. STRUCTURED BINDINGS in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#76.-How-to-Deal-with-OPTIONAL-Data-in-C++">76. How to Deal with OPTIONAL Data in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#77.-Multiple-TYPES-of-Data-in-a-SINGLE-VARIABLE-in-C++?">77. Multiple TYPES of Data in a SINGLE VARIABLE in C++?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#78.-How-to-store-ANY-data-in-C++">78. How to store ANY data in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#79.-How-to-make-C++-run-FASTER-(with-std::async)">79. How to make C++ run FASTER (with std::async)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#80.-How-to-make-your-STRINGS-FASTER-in-C++!">80. How to make your STRINGS FASTER in C++!</a></li>
<li class="toctree-l2"><a class="reference internal" href="#81.-VISUAL-BENCHMARKING-in-C++-(how-to-measure-performance-visually)">81. VISUAL BENCHMARKING in C++ (how to measure performance visually)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#82.-SINGLETONS-in-C++">82. SINGLETONS in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#83.-Small-String-Optimization-in-C++">83. Small String Optimization in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#84.-Track-MEMORY-ALLOCATIONS-the-Easy-Way-in-C++">84. Track MEMORY ALLOCATIONS the Easy Way in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#85.-lvalues-and-rvalues-in-C++">85. lvalues and rvalues in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#86.-Continuous-Integration-in-C++">86. Continuous Integration in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#87.-Static-Analysis-in-C++">87. Static Analysis in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#88.-Argument-Evaluation-Order-in-C++">88. Argument Evaluation Order in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#89.-Move-Semantics-in-C++">89. Move Semantics in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#90.-std::move-and-the-Move-Assignment-Operator-in-C++">90. std::move and the Move Assignment Operator in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#91.-ARRAY---Making-DATA-STRUCTURES-in-C++">91. ARRAY - Making DATA STRUCTURES in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="#92.-VECTOR/DYNAMIC-ARRAY---Making-DATA-STRUCTURES-in-C++">92. VECTOR/DYNAMIC ARRAY - Making DATA STRUCTURES in C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="DS%20and%20Algo.html">DS and Algo</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fun%20Math.html">Fun Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="GMM.html">GMM</a></li>
<li class="toctree-l1"><a class="reference internal" href="Notes.html">Misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="Piano.html">Piano</a></li>
<li class="toctree-l1"><a class="reference internal" href="Questions_c.html">Question_c</a></li>
<li class="toctree-l1"><a class="reference internal" href="Questions_m.html">Questions_m</a></li>
<li class="toctree-l1"><a class="reference internal" href="Theory.html">Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="Untitled.html">Not All LeetCode Questions are Created Equal</a></li>
<li class="toctree-l1"><a class="reference internal" href="Untitled.html#Gauss-Quadrature">Gauss Quadrature</a></li>
<li class="toctree-l1"><a class="reference internal" href="LC/19.html">19</a></li>
<li class="toctree-l1"><a class="reference internal" href="LC/CPP.html">CPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="LC/DP.html">DP</a></li>
<li class="toctree-l1"><a class="reference internal" href="LC/Misc.html">Misc</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MiscBeginnerSC</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>CPP – Notes on The Cherno C++ Videos</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/CPP.ipynb.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="CPP-–-Notes-on-The-Cherno-C++-Videos">
<h1>CPP – Notes on <a class="reference external" href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">The Cherno C++ Videos</a><a class="headerlink" href="#CPP-–-Notes-on-The-Cherno-C++-Videos" title="Permalink to this headline">¶</a></h1>
<div class="section" id="1.-Welcome-to-C++">
<h2>1. Welcome to C++<a class="headerlink" href="#1.-Welcome-to-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="2.-How-to-Setup-C++-on-Windows">
<h2>2. How to Setup C++ on Windows<a class="headerlink" href="#2.-How-to-Setup-C++-on-Windows" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://youtu.be/1OsGXuNA5cc?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=259">The Cherno’s VS Settings</a></p></li>
</ul>
</div>
<div class="section" id="3.-How-to-Setup-C++-on-Mac">
<h2>3. How to Setup C++ on Mac<a class="headerlink" href="#3.-How-to-Setup-C++-on-Mac" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="4.-How-to-Setup-C++-on-Linux">
<h2>4. How to Setup C++ on Linux<a class="headerlink" href="#4.-How-to-Setup-C++-on-Linux" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="5.-How-C++-Works">
<h2>5. <a class="reference external" href="https://www.youtube.com/watch?v=SfGuIVzE_Os&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=5">How C++ Works</a><a class="headerlink" href="#5.-How-C++-Works" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>int main() 可以不用 return 0 。只有 main() 可以這樣</p></li>
<li><p>&lt;&lt; operator 也是一個函數</p></li>
<li><p>一個 cpp 檔裡只要所有用到的變數函數都找的到宣告，compiler 就相信它存在，實際定義在哪是 linker 要負責找到。</p></li>
<li><p>在同一個 cpp file 裡只要所有函數變數都找的宣告就可以編譯。不需要另外 include</p></li>
<li><p>把 text 編譯成 binary file 的三個步驟：</p>
<ul>
<li><p>preprocess: h -&gt; cpp</p></li>
<li><p>compile: cpp -&gt; obj</p></li>
<li><p>link: obj files -&gt; exe</p></li>
</ul>
</li>
<li><p>platform &amp; configuration ：</p>
<ul>
<li><p>platform 如 x86 是 target platform（x86==win32）</p></li>
<li><p>configuration 如 Debug/Release 是 build config</p></li>
<li><p>檢查跟 property 裡的一樣。VS 有時候會弄錯</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="6.-How-the-C++-Compiler-Works">
<h2>6. <a class="reference external" href="https://www.youtube.com/watch?v=3tIqpEmWMLI&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=7&amp;t=0s">How the C++ Compiler Works</a><a class="headerlink" href="#6.-How-the-C++-Compiler-Works" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>preprocessor 只負責複製貼上。把 <code class="docutils literal notranslate"><span class="pre">}</span></code> 改成 <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;EndBrace.h&quot;</span></code> 結果是一樣的</p></li>
<li><p>*.i file 是 preprocess 過的 cpp file</p></li>
<li><p>compile 是 compile cpp files individually 的意思，在 windows 裡編譯完得 obj 檔被 VS 丟到 /Debug 裡</p></li>
<li><p>C++ 沒有 file 的概念，只有 translation unit ：</p>
<ul>
<li><p>用 include 把 a.cpp 貼到 b.cpp，再把 b.cpp 貼到 c.cpp，最後只編譯 c.cpp，這樣就只有一個很大的 translation unit</p></li>
</ul>
</li>
<li><p>compile 得到的 obj file 是 binary。要得到可讀的 assembly code 可以在 VS 改：</p>
<ul>
<li><p>Porperty -&gt; C/C++ -&gt; Output Files -&gt; Assumbler Output 改成 Assembling only listing</p></li>
<li><p>改好之後重新編譯，除了 obj 還會得到 asm file 是可讀的</p></li>
</ul>
</li>
<li><p>O2 編譯是優化速度。還可以優化別的： <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">f(int</span> <span class="pre">a,</span> <span class="pre">int</span> <span class="pre">b)</span>&#160;&#160;&#160;&#160; <span class="pre">{</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">int</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">a*b;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">return</span> <span class="pre">c;</span>&#160;&#160;&#160;&#160; <span class="pre">}</span></code> 這裡 O2 會編成 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">a*b</span></code>，在 assembly 省下一個 mov</p></li>
<li><p>因為 O2 不是一行一行編譯所以沒辦法 debug</p></li>
<li><p>Constant Folding：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">5*2;</span></code> 會直接編譯成 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">10;</span></code> 就算在 debug mode 也一樣</p></li>
<li><p>所有編譯時期能決定的 constant 就會直接算出結果放在 assembly</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="7.-How-the-C++-Linker-Works">
<h2>7. <a class="reference external" href="https://www.youtube.com/watch?v=H4s55GgAg0I&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=7">How the C++ Linker Works</a><a class="headerlink" href="#7.-How-the-C++-Linker-Works" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>一個函數只要在某個檔案定義過了 linker 就找的到，和 include 無關，include 只需要 include 宣告</p></li>
<li><p>linker 找的是 function signature</p></li>
<li><p>一個程式的 entry point 不一定就是 main function，雖然大部份時候都是</p></li>
<li><p>分清楚 error 是 compiling（error code C 開頭）還是 linking error（LNK 開頭）</p></li>
<li><p>兩種常見 linking error：</p>
<ul>
<li><p>unresolved external symbol：有變數或函數找不到定義</p></li>
<li><p>one or more multiple defined symbols found：有變數或函數重覆定義，有可能是 preprocessor 貼兩次的結果，solution：</p>
<ul>
<li><p>把函數宣告成 static，只有那個 translation unit 看的到</p></li>
<li><p>宣告成 inline</p></li>
<li><p>不要把函數定義在 h 檔裡，定義在 cpp 檔，自成一個 translation unit</p></li>
<li><p><cite>除了第一次定義之外，其它都用 extern，如 ``extern int a;`</cite> &lt;<a class="reference external" href="https://youtu.be/f3FVU-iwNuA?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=150">https://youtu.be/f3FVU-iwNuA?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=150</a>&gt;`__</p></li>
</ul>
</li>
</ul>
</li>
<li><p>linker 也用來 link 其它 library 如 STL，platform API</p></li>
<li><p>linking 有分 static 和 dynamic</p></li>
</ul>
</div>
<div class="section" id="8.-Variables-in-C++">
<h2>8. <a class="reference external" href="https://www.youtube.com/watch?v=zB9RI8_wExo&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=8">Variables in C++</a><a class="headerlink" href="#8.-Variables-in-C++" title="Permalink to this headline">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Size (Bytes)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bool</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>char</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>short</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>int</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>long</p></td>
<td><p>4*</p></td>
</tr>
<tr class="row-odd"><td><p>long long</p></td>
<td><p>4*</p></td>
</tr>
<tr class="row-even"><td><p>float</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>double</p></td>
<td><p>8</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>* 代表 compiler dependent</p></li>
<li><p>可以用 sizeof 來查</p></li>
<li><p>C++ 所有 primitive type 其實都是數字，差別只在暫記憶體空間大小</p></li>
<li><p>bool 其實只需要一個 bit，可是 memory 都是以 byte 為單位讀，所以就用 1 byte 來存</p></li>
<li><p>float 宣告會自動變成 double 除非宣告成這樣 <code class="docutils literal notranslate"><span class="pre">float</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">5.5f;</span></code></p></li>
</ul>
</div>
<div class="section" id="9.-Functions-in-C++">
<h2>9. <a class="reference external" href="https://www.youtube.com/watch?v=V9zuox47zr0&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=9">Functions in C++</a><a class="headerlink" href="#9.-Functions-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>常常複製貼上一段 code 之後忘了改一些細節。如果一段 code 會被複製貼上很多次就該包成函數</p></li>
<li><p>練習把 code 拆成很多很多函數</p></li>
<li><p>但不要 over do it 因為有 context switch overhead 會變慢。function 的 assembly code 在 binary 的其它位置</p></li>
</ul>
</div>
<div class="section" id="10.-C++-Header-Files">
<h2>10. <a class="reference external" href="https://www.youtube.com/watch?v=9RJTQmK0YPI&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=10">C++ Header Files</a><a class="headerlink" href="#10.-C++-Header-Files" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>如果沒有 header file，每一個 translation unit 都要把自己用到的所有函數重新宣告一次。有 header file 就可以用 include 的就好</p></li>
<li><p>在一個 header file 的最前面放 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">once</span></code> 可以避免這個 header file <a class="reference external" href="https://en.wikipedia.org/wiki/Pragma_once#Example">被重覆 include</a>，效果同把整個 header file 的內容包在 ifndef 裡： <code class="docutils literal notranslate"><span class="pre">#ifndef</span> <span class="pre">_LOG_H_</span>&#160;&#160;&#160;&#160; <span class="pre">#define</span> <span class="pre">_LOG_H_</span>&#160;&#160;&#160;&#160; <span class="pre">#endif</span></code></p></li>
<li><p>現在已經差不多所有編譯器都支援 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">once</span></code> 了</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;header&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;header.h&quot;</span></code> 的差別：</p>
<ul>
<li><p>編譯的時候可以指定一些 include path，用括號的 include 是從這些 path 中找，用雙引號的 include 是用該 cpp file 的相對位置找</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;header.h&quot;</span></code> 代表這個 header 和 cpp 在同一個 folder</p></li>
<li><p>其實雙引號也會去 include path 找所以 <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;iostream&quot;</span></code> 是可以的</p></li>
</ul>
</li>
<li><p>C++ 自帶的 header file 是沒有副檔名的，所以不能 <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream.h&gt;</span></code>，會找不到。但是 C 自帶的是有的，例如 <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;math.h&gt;</span></code></p></li>
</ul>
</div>
<div class="section" id="11.-How-to-DEBUG-C++-in-VISUAL-STUDIO">
<h2>11. How to DEBUG C++ in VISUAL STUDIO<a class="headerlink" href="#11.-How-to-DEBUG-C++-in-VISUAL-STUDIO" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="12.-CONDITIONS-and-BRANCHES-in-C++-(if-statements)">
<h2>12. CONDITIONS and BRANCHES in C++ (if statements)<a class="headerlink" href="#12.-CONDITIONS-and-BRANCHES-in-C++-(if-statements)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="13.-BEST-Visual-Studio-Setup-for-C++-Projects!">
<h2>13. BEST Visual Studio Setup for C++ Projects!<a class="headerlink" href="#13.-BEST-Visual-Studio-Setup-for-C++-Projects!" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="14.-Loops-in-C++-(for-loops,-while-loops)">
<h2>14. Loops in C++ (for loops, while loops)<a class="headerlink" href="#14.-Loops-in-C++-(for-loops,-while-loops)" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">for(i=0</span> <span class="pre">;</span> <span class="pre">i&lt;=4</span> <span class="pre">;</span> <span class="pre">i++)</span></code> 會比 <code class="docutils literal notranslate"><span class="pre">for(i=0</span> <span class="pre">;</span> <span class="pre">i&lt;5</span> <span class="pre">;</span> <span class="pre">i++)</span></code> 慢因為 <code class="docutils literal notranslate"><span class="pre">i&lt;=4</span></code> 其實是兩次比較。只要情況允許應該永遠寫 <code class="docutils literal notranslate"><span class="pre">i&lt;5</span></code></p></li>
</ul>
</div>
<div class="section" id="15.-Control-Flow-in-C++-(continue,-break,-return)">
<h2>15. Control Flow in C++ (continue, break, return)<a class="headerlink" href="#15.-Control-Flow-in-C++-(continue,-break,-return)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="16.-POINTERS-in-C++">
<h2>16. <a class="reference external" href="https://www.youtube.com/watch?v=DTxHyVn0ODg&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=16">POINTERS in C++</a><a class="headerlink" href="#16.-POINTERS-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>不管是 <code class="docutils literal notranslate"><span class="pre">int*</span></code>, <code class="docutils literal notranslate"><span class="pre">char*</span></code>, <code class="docutils literal notranslate"><span class="pre">double*</span></code> 都一樣是整數</p></li>
<li><p>以下三個都相同： <code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">ptr</span> <span class="pre">=</span> <span class="pre">nullptr;</span>&#160;&#160;&#160;&#160; <span class="pre">void*</span> <span class="pre">ptr</span> <span class="pre">=</span> <span class="pre">NULL;</span>&#160;&#160;&#160;&#160; <span class="pre">void*</span> <span class="pre">ptr</span> <span class="pre">=</span> <span class="pre">0;</span></code></p></li>
<li><p>記憶體零的位置不能讀寫，如果試著去讀程式會 crash，但上面這些 statement 是合法的編譯可以過</p></li>
<li><p><a class="reference external" href="https://youtu.be/DTxHyVn0ODg?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=412">VS 是有辦法看到 memory 裡有什麼的！</a></p>
<ul>
<li><p>看到的是反的。<code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">5;</span></code> 在記憶體裡會看到 <code class="docutils literal notranslate"><span class="pre">05</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">00</span></code></p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://youtu.be/DTxHyVn0ODg?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=668">還能看著 memory debug</a>，<a class="reference external" href="https://youtu.be/DTxHyVn0ODg?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=808">直接打 pointer 的變數名稱也行</a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;a</span></code>：a 的位址，<code class="docutils literal notranslate"><span class="pre">*p</span></code>：p 裡面住的人</p></li>
<li><p>cast <code class="docutils literal notranslate"><span class="pre">int*</span></code> into <code class="docutils literal notranslate"><span class="pre">double*</span></code> （反正所有 ptr 都是整數） <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">var</span> <span class="pre">=</span> <span class="pre">8;</span>&#160;&#160;&#160;&#160; <span class="pre">double*</span> <span class="pre">ptr</span> <span class="pre">=</span> <span class="pre">(double*)&amp;var</span></code></p></li>
<li><p>cstring memset 把一塊連續的記憶體設成同一個值 <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">include</span> <span class="pre">&lt;cstring&gt;</span>&#160;&#160;&#160;&#160; <span class="pre">int</span> <span class="pre">main()</span>&#160;&#160;&#160;&#160; <span class="pre">{</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">char*</span> <span class="pre">buffer</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">char[8];</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">std::memset(buffer,</span> <span class="pre">0,</span> <span class="pre">8);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">delete[]</span> <span class="pre">buffer;</span>&#160;&#160;&#160;&#160; <span class="pre">}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int*</span> <span class="pre">a,</span> <span class="pre">b;</span></code> <a class="reference external" href="https://youtu.be/4fJBrditnJU?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=470">這樣宣告只有 a 是指標</a>，b 還是整數。如果要兩個指標要宣告成 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*a,</span> <span class="pre">*b;</span></code></p></li>
</ul>
</div>
<div class="section" id="17.-REFERENCES-in-C++">
<h2>17. <a class="reference external" href="https://www.youtube.com/watch?v=IzoFn3dfsPA&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=17">REFERENCES in C++</a><a class="headerlink" href="#17.-REFERENCES-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>函數傳參考呼叫的寫法</p></li>
<li><p>宣告參考的時候一定要初始化（沒有本名哪有別名）（it’s not a real variable, it’s a reference）</p></li>
<li><p>一旦初始化就不能改變。下面這段 code 只會把 a 的值設成 5，不會把 ref 變成 b 的別名</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="nb">int</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="18.-CLASSES-in-C++">
<h2>18. CLASSES in C++<a class="headerlink" href="#18.-CLASSES-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="19.-CLASSES-vs-STRUCTS-in-C++">
<h2>19. <a class="reference external" href="https://www.youtube.com/watch?v=fLgTtaqqJp0&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=19">CLASSES vs STRUCTS in C++</a><a class="headerlink" href="#19.-CLASSES-vs-STRUCTS-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>差別真的就只有 struct 預設是 public，class 預設是 private</p></li>
<li><p>The Cherno 遇到真的只用來裝 data 的才用 struct，然後從來不繼承 struct</p></li>
</ul>
</div>
<div class="section" id="20.-How-to-Write-a-C++-Class">
<h2>20. How to Write a C++ Class<a class="headerlink" href="#20.-How-to-Write-a-C++-Class" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="21.-Static-in-C++">
<h2>21. <a class="reference external" href="https://www.youtube.com/watch?v=f3FVU-iwNuA&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=22&amp;t=0s">Static in C++</a><a class="headerlink" href="#21.-Static-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>static 分成在 class 裡的和在 class 外的，意義不同，這裡講在 class 外的</p></li>
<li><p>external linkage：在不同 translation unit 裡重覆定義非 static 變數會出現 linking error。要避免這個錯誤可以定義成 <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">int</span> <span class="pre">a;</span></code> 叫 linker 去其它 translation unit 找</p></li>
<li><p>internal linkage：在一個 translation unit 的全域範圍裡的 static 只有該 translation unit 看的到。linker 從外部找不到，就算用 extern 也找不到。這個變數就像是這個 translation unit 的 private 變數</p></li>
<li><p>static 函數也一樣，只有該 translation unit 看的到。這樣定義：<code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">void</span> <span class="pre">Function(){}</span></code></p></li>
<li><p>如果在標頭檔裡定義 static 變數然後這個標頭檔被兩個 cpp file include，由於 preprocessor 只是單純的複製貼上，這相當於在兩個 translation unit 裡各自定義 static 變數</p></li>
<li><p>就像 class 裡的儘量把外部用不到的變數函數定義成 private 一樣，全域變數也應該儘量定義成 static，除非真的需要它被 linker 找到</p></li>
</ul>
</div>
<div class="section" id="22.-Static-for-Classes-and-Structs-in-C++">
<h2>22. <a class="reference external" href="https://www.youtube.com/watch?v=V-BFlMrBtqQ&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=23&amp;t=0s">Static for Classes and Structs in C++</a><a class="headerlink" href="#22.-Static-for-Classes-and-Structs-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>在 class 裡的 static variable 只有一個 instance。不管宣告多少這個 class 的 instances 都共用同一個該 variable。然後在全域要用 scope resolution operator 再宣告一次</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Entity</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">static</span> <span class="nb">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">static</span> <span class="n">void</span> <span class="n">Print</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">Entity</span><span class="p">::</span><span class="n">a</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Entity</span> <span class="n">e</span><span class="p">;</span>
    <span class="n">e</span><span class="o">.</span><span class="n">a</span><span class="p">;</span>
    <span class="n">e</span><span class="o">.</span><span class="n">Print</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>上面的 <code class="docutils literal notranslate"><span class="pre">e.a</span></code> 是合法的編譯會過，但觀念正確的呼叫方式應該是 <code class="docutils literal notranslate"><span class="pre">Entity::a</span></code></p></li>
<li><p>static 成員變數可以是 private，所以比全域變數更好控制權限</p></li>
<li><p>非 static 的所有 class 成員函數經過編譯其實都有一個像 python 的 self 把呼叫自己的物件傳進去，static 成員函數沒有，所以如果要存取其它成員變數，只能存取 static 成員變數。沒有 self 就沒辦法透過 self 物件存取裡面的變數</p></li>
</ul>
</div>
<div class="section" id="23.-Local-Static-in-C++">
<h2>23. <a class="reference external" href="https://www.youtube.com/watch?v=f7mtWD9GdJ4&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=23">Local Static in C++</a><a class="headerlink" href="#23.-Local-Static-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>在一個 local scope（如函數，if statement）裡的 static 變數 lifetime 會變成永遠，但 scope 不變</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Function</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul>
<li><p>上面這段 code 有點像把 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span></code> 移到全域。如果呼叫這個函數五次，i 就會被遞增五次（所以可以計算這個函數被呼叫了多少次）</p>
<ul class="simple">
<li><p>上面這段 code 的初始化 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">0</span></code> 只會做一次，因為第二次以後呼叫這個函數時 i 已經存在了不需要初始化</p></li>
</ul>
</li>
<li><p>那為什麼不用全域變數就好了？因為 local static 變數不會改變 scope，只有這個函數能計算自己被呼叫的次數。如果宣告成全域變數，在呼叫五次的過程中可能有其它 code 會改變 i 的值</p></li>
<li><p>兩種 Singleton 的寫法，行為完全一樣，用 local static 寫比較乾淨</p>
<ul class="simple">
<li></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
<span class="n">private</span><span class="p">:</span>
    <span class="n">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">s_Instance</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">static</span> <span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">s_Instance</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">void</span> <span class="n">Hello</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="n">singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="p">::</span><span class="n">s_Instance</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Singleton</span><span class="p">::</span><span class="n">Get</span><span class="p">()</span><span class="o">.</span><span class="n">Hellow</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">static</span> <span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">Get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">static</span> <span class="n">Singleton</span> <span class="n">instance</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">void</span> <span class="n">Hello</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Singleton</span><span class="p">::</span><span class="n">Get</span><span class="p">()</span><span class="o">.</span><span class="n">Hellow</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>上面第二種寫法裡的 <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">Singleton</span> <span class="pre">instance;</span></code> 只有第一次被呼叫時真正 new 了一個 Singleton，之後就一直用同一個 instance</p></li>
</ul>
</div>
<div class="section" id="24.-ENUMS-in-C++">
<h2>24. <a class="reference external" href="https://www.youtube.com/watch?v=x55jfOd5PEE&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=25&amp;t=0s">ENUMS in C++</a><a class="headerlink" href="#24.-ENUMS-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>幫整數取名字，增加可讀性</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>enum Example : unsigned char  // 如果不指定預設為 int。不可以用 float 因為一定要整數
{
    A=0, B=2, C=6  // 如果不指定而只寫 A, B, C 預設為 0, 1, 2
};
int main()
{
    Example value = B;
}
</pre></div>
</div>
<ul class="simple">
<li><p>Log class 例子：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class Log
{
public:
    enum Level
    {
        LevelError=0, LevelWarning, LevelInfo  // 這樣初始化可以增加可讀性。代表 0, 1, 2
    }
private:
    Level m_LogLevel = LevelInfo;
public:
    void SetLevel(Level level)
    {
        m_LogLevel = level;
    }
    void Error(const char* message)
    {
        if (m_LogLevel &gt;= LevelError)
            std::cout &lt;&lt; &quot;[ERROR]: &quot; &lt;&lt; message &lt;&lt; std::end;
    }
    void Warn(const char* message)
    {
        if (m_LogLevel &gt;= LevelWarning)
            std::cout &lt;&lt; &quot;[WARNING]: &quot; &lt;&lt; message &lt;&lt; std::end;
    }
    void Info(const char* message)
    {
        if (m_LogLevel &gt;= LevelInfo)
            std::cout &lt;&lt; &quot;[INFO]: &quot; &lt;&lt; message &lt;&lt; std::end;
    }
};
int main()
{
    Log log;
    log.SetLevel(Log::LevelError);  // scope operator
    log.Warn(&quot;Hello!&quot;);
    std::cin.get();
}
</pre></div>
</div>
<ul class="simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">m_LogLevel</span></code> 是 int，有可能會不小心被改成 5。宣告成 Level 會比較安全</p></li>
<li><p>SetLevel 裡用 scope operator <code class="docutils literal notranslate"><span class="pre">Log::LevelError</span></code> 就像 LevelError 是一個成員變數一樣。enum Level 裡並不是一個 namespace 而是有一個 enum class</p>
<ul>
<li><p>所以這個例子裡 enum 變數不能叫 Error，會跟成員函數重名</p></li>
<li><p>像這個例子的 enum 裡變數名前面灌上該 enum 的名稱也是 common practice</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="25.-Constructors-in-C++">
<h2>25. Constructors in C++<a class="headerlink" href="#25.-Constructors-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="26.-Destructors-in-C++">
<h2>26. Destructors in C++<a class="headerlink" href="#26.-Destructors-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="27.-Inheritance-in-C++">
<h2>27. Inheritance in C++<a class="headerlink" href="#27.-Inheritance-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="28.-Virtual-Functions-in-C++">
<h2>28. <a class="reference external" href="https://www.youtube.com/watch?v=oIV2KchSyGQ&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=29&amp;t=0s">Virtual Functions in C++</a><a class="headerlink" href="#28.-Virtual-Functions-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>父類別指標可以指向子類別物件，然後通過 arrow operator 呼叫子類別版本的 virtual 成員函數</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Entity</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">virtual</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">GetName</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;Entity&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Player</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Entity</span>
<span class="p">{</span>
<span class="n">private</span><span class="p">:</span>
    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">m_Name</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">Player</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">:</span> <span class="n">m_Name</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">GetName</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_Name</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="n">void</span> <span class="n">PrintName</span><span class="p">(</span><span class="n">Entity</span><span class="o">*</span> <span class="n">entity</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">entity</span><span class="o">-&gt;</span><span class="n">GetName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Player</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Player</span><span class="p">(</span><span class="s2">&quot;Cherno&quot;</span><span class="p">);</span>
    <span class="n">PrintName</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cin</span><span class="o">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>這裡被傳進 PrintName 的指標實際上是指向子類物件還是父類物件，編譯時期是不知道的</p></li>
<li><p>C++11 之後子類裡的 override 成員函數定義裡可以加上 override 關鍵字，不是強制的但</p>
<ol class="arabic simple">
<li><p>可以增加可讀性</p></li>
<li><p>可以避免函數名字打錯（如果打成 GETNAME() override 編譯會出錯）</p></li>
<li><p>如果父類裡忘了宣告這個函數為 virtual 編譯也會出錯</p></li>
</ol>
</li>
<li><p>overhead</p>
<ol class="arabic simple">
<li><p>父類裡多出 4 bytes 用來存指向子類 vtable 的指標</p></li>
<li><p>到了子類要查 vtable 找到想要的函數</p></li>
</ol>
</li>
</ul>
</div>
<div class="section" id="28.5-Vtable">
<h2>28.5 <a class="reference external" href="https://www.youtube.com/watch?v=VdvL8kFBubU">Vtable</a><a class="headerlink" href="#28.5-Vtable" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>如果沒有任何 virtual function，sizeof 一個類別就是所有成員變數總和（成員函數不佔空間）。一旦出現 virtual function 而成為一個父類，sizeof 會多出 4 bytes 用來存指向子類 vtable 的指標</p></li>
<li><p>每一個子類有一個自己的 vtable，同一個子類的所有 instance 都共用這個 vtable</p></li>
<li><p>vtable 裡有很多函數指標，指向所有在這個子類裡有 override 的 virtual function</p></li>
<li><p>vtable 簡介在 Stroustrup 的 The C++ Programming Language, 4th Ed 第三章（p.67）</p></li>
</ul>
</div>
<div class="section" id="29.-Interfaces-in-C++-(Pure-Virtual-Functions)">
<h2>29. <a class="reference external" href="https://www.youtube.com/watch?v=UWAdd13EfM8&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=30&amp;t=0s">Interfaces in C++ (Pure Virtual Functions)</a><a class="headerlink" href="#29.-Interfaces-in-C++-(Pure-Virtual-Functions)" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>在父類裡把某個成員函數的 body 拿掉換成 <code class="docutils literal notranslate"><span class="pre">=0;</span></code>，這個父類就變成 interface，不能有自己的 object，並且強迫所有子類要 override 這個函數</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">virtual</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">GetName</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="30.-Visibility-in-C++">
<h2>30. Visibility in C++<a class="headerlink" href="#30.-Visibility-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="31.-Arrays-in-C++">
<h2>31. <a class="reference external" href="https://www.youtube.com/watch?v=ENDaJi08jCU&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=32&amp;t=0s">Arrays in C++</a><a class="headerlink" href="#31.-Arrays-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Lua array index 從 1 開始</p></li>
<li><p>如果存到超出 array 的範圍，在 debug mode 會 crash 但在 release mode 不會有任何警告，然後就會很難 debug</p></li>
<li><p>pointer arithmetic： main 裡面的三行做的事一樣</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="nb">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="nb">int</span><span class="o">*</span><span class="p">)((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ptr</span> <span class="pre">+</span> <span class="pre">2</span></code> 實際上在記憶體裡要 offset 幾個 byte 取決於 ptr 是哪一類的指標。int 佔 4 bytes，char 只佔 1 byte，所以如果把 ptr cast 成 char* 之後要加 8 才會指到同一個位址（然後還要 cast 回來）</p></li>
<li><p>stack 和 heap based array 的差別</p>
<ol class="arabic simple">
<li><p>lifetime：stack based 只看 scope，new 出來的要一直到看到 delete 才會消失</p></li>
<li><p>new 比較慢因為會有 memory fragmentation，cache misses</p></li>
</ol>
</li>
<li><p>C++11 之後有 std::array。儘量用 std::array 取代 raw array</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;array&gt;</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">():</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="n">array</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>stack based array 例如 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">a[5];</span></code> 可以這樣算出長度 <code class="docutils literal notranslate"><span class="pre">sizeof(a)/size(int)</span></code>，heap based 就沒辦法了（其實有辦法但是 compiler dependent，不要用）</p></li>
<li><p>用一個變數來 manage size：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">const</span> <span class="nb">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">a</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
</pre></div>
</div>
<ul class="simple">
<li><p>這裡一定要用 static const 因為 stack based array 長度必需在編譯時期就知道。如果是 heap based 就不用</p></li>
</ul>
</div>
<div class="section" id="32.-How-Strings-Work-in-C++-(and-how-to-use-them)">
<h2>32. How Strings Work in C++ (and how to use them)<a class="headerlink" href="#32.-How-Strings-Work-in-C++-(and-how-to-use-them)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="33.-String-Literals-in-C++">
<h2>33. String Literals in C++<a class="headerlink" href="#33.-String-Literals-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="34.-CONST-in-C++">
<h2>34. <a class="reference external" href="https://www.youtube.com/watch?v=4fJBrditnJU&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=35&amp;t=0s">CONST in C++</a><a class="headerlink" href="#34.-CONST-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int*</span> <span class="pre">const</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">int;</span></code> 不能改指向別的位址，但可以改裡面住的人（從右往左讀：a 是一個 const）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int*</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">int;</span></code> 可以改指向別的位址，但不能改裡面住的人（從右往左讀：a 是一個指標，指向 const int）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">const*</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">int;</span></code> 同上。只有 const 放在 * 前後會有差別</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int*</span> <span class="pre">const</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">int;</span></code> 位址和內容都不能改</p></li>
<li><p>const 成員變數，不能改任何成員變數</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Entity</span>
<span class="p">{</span>
<span class="n">private</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">m_x</span><span class="p">,</span> <span class="n">m_y</span><span class="p">;</span>
    <span class="n">mutable</span> <span class="nb">int</span> <span class="n">val</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">GetX</span><span class="p">()</span> <span class="n">const</span>
    <span class="p">{</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>    <span class="o">//</span> <span class="n">宣告成</span> <span class="n">mutable</span> <span class="n">的成員變數可以改</span>
        <span class="k">return</span> <span class="n">m_x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int*</span> <span class="pre">const</span> <span class="pre">GetPtr()</span> <span class="pre">const</span></code> 回傳一個指標，位址和內容都不能改，並且這個成員函數也不更改任何成員變數</p></li>
<li><p>下面這個函數裡 e 只能呼叫 const 成員函數，因為傳進來的時候就被限定是 const ref，不能改 e 裡面的任何東西。所以有時候會看到同樣的成員函數被定義兩次，一次是 const 另一次不是</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">PrintEntity</span><span class="p">(</span><span class="n">const</span> <span class="n">Entity</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="o">.</span><span class="n">GetX</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="35.-The-Mutable-Keyword-in-C++">
<h2>35. <a class="reference external" href="https://www.youtube.com/watch?v=bP9z3H3cVMY&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=35">The Mutable Keyword in C++</a><a class="headerlink" href="#35.-The-Mutable-Keyword-in-C++" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>mutable 關鍵字有兩個不同的意義：</p>
<ol class="arabic">
<li><p>使某成員變數在 const 成員函數裡能被改寫，看上面的例子。大部份時候是為了 debug，如果直接把該成員函數改成 non-const 可能會 break 別的東西</p></li>
<li><p>lambda（The Cherno 實務上從來沒看過人這麼寫，從來不需要）</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">[=]()</span></code> 把 scope 裡所有東西傳進去，by value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">[&amp;]()</span></code> 把 scope 裡所有東西傳進去，by ref</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>int main()
{
    int x = 8;
    auto f = [=]() mutable
    {
        x++;  // call by value 的時候如果不把這個 lambda 函數宣告成 mutable，就不能改內容
        std::cout &lt;&lt; x &lt;&lt; std::end;
    };
    f();
    // x 還是 8，並沒有被遞增，因為 call by value
}
</pre></div>
</div>
</li>
</ol>
</li>
</ul>
</div>
<div class="section" id="36.-Member-Initializer-Lists-in-C++-(Constructor-Initializer-List)">
<h2>36. Member Initializer Lists in C++ (Constructor Initializer List)<a class="headerlink" href="#36.-Member-Initializer-Lists-in-C++-(Constructor-Initializer-List)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="37.-Ternary-Operators-in-C++-(Conditional-Assignment)">
<h2>37. Ternary Operators in C++ (Conditional Assignment)<a class="headerlink" href="#37.-Ternary-Operators-in-C++-(Conditional-Assignment)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="38.-How-to-CREATE/INSTANTIATE-OBJECTS-in-C++">
<h2>38. How to CREATE/INSTANTIATE OBJECTS in C++<a class="headerlink" href="#38.-How-to-CREATE/INSTANTIATE-OBJECTS-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="39.-The-NEW-Keyword-in-C++">
<h2>39. The NEW Keyword in C++<a class="headerlink" href="#39.-The-NEW-Keyword-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="40.-Implicit-Conversion-and-the-Explicit-Keyword-in-C++">
<h2>40. Implicit Conversion and the Explicit Keyword in C++<a class="headerlink" href="#40.-Implicit-Conversion-and-the-Explicit-Keyword-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="41.-OPERATORS-and-OPERATOR-OVERLOADING-in-C++">
<h2>41. OPERATORS and OPERATOR OVERLOADING in C++<a class="headerlink" href="#41.-OPERATORS-and-OPERATOR-OVERLOADING-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="42.-The-“this”-keyword-in-C++">
<h2>42. The “this” keyword in C++<a class="headerlink" href="#42.-The-“this”-keyword-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="43.-Object-Lifetime-in-C++-(Stack/Scope-Lifetimes)">
<h2>43. <a class="reference external" href="https://www.youtube.com/watch?v=iNuTwvD6ciI">Object Lifetime in C++ (Stack/Scope Lifetimes)</a><a class="headerlink" href="#43.-Object-Lifetime-in-C++-(Stack/Scope-Lifetimes)" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>直接宣告變數獲得的記憶體空間 stack based</p>
<ul>
<li><p>每一層 scope 都是 stack 上的一個 frame。每新建一個 scope 就是在 push，就像把一本書放到一整疊書的最上面。當在這個 scope 裡宣告變數就等於是把它寫在這本書裡。離開這個 scope 就是 pop，把這本書連同所有內容全部丟掉</p></li>
</ul>
</li>
<li><p>用 new 配置的記憶體空間是 heap based，在 delete 之前這塊空間是不會消失的</p></li>
<li><p>常見錯誤：在函數裡配置 stack based 記憶體空間然後回傳指標，這樣做一出函數時配置給 a 的記憶體空間就消失了</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span><span class="o">*</span> <span class="n">CreateArray</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
<span class="p">}</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">int</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">CreateArray</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul>
<li><p>Scoped class：寫一個 class 當作 python 的 with 來用。用 ctor 和 dtor 來當作 <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__exit__</span></code>，可以用來寫：</p>
<ul class="simple">
<li><p>timer</p></li>
<li><p>mutex locking for multithreading</p></li>
<li><p>scoped pointer，如 unique pointer：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ScopedPtr</span>
<span class="p">{</span>
<span class="n">private</span><span class="p">:</span>
    <span class="n">Entity</span><span class="o">*</span> <span class="n">m_Ptr</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">ScopedPtr</span><span class="p">(</span><span class="n">Entity</span><span class="o">*</span> <span class="n">ptr</span><span class="p">):</span> <span class="n">m_Ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">){}</span>
    <span class="o">~</span><span class="n">ScopedPtr</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">delete</span> <span class="n">m_Ptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="n">ScopedPtr</span> <span class="n">e</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Entity</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="44.-SMART-POINTERS-in-C++-(std::unique_ptr,-std::shared_ptr,-std::weak_ptr)">
<h2>44. <a class="reference external" href="https://www.youtube.com/watch?v=UOB7-B2MfwA&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=45&amp;t=0s">SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)</a><a class="headerlink" href="#44.-SMART-POINTERS-in-C++-(std::unique_ptr,-std::shared_ptr,-std::weak_ptr)" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>new 完不用 delete，在 out of scope 時記憶體會自動被釋放（物件毀滅）</p></li>
<li><p>試著用 smart pointers 取代 raw pointers。能用 unique_ptr 就用 unique_ptr，真正需要 share 的時候才用 shared_ptr</p></li>
<li><p>unique_ptr：</p>
<ul class="simple">
<li><p>不能被複製。因為如果 ptr1 = ptr2，後來 pt1 先 go out of scope 了，所指向的物件就會毀滅，繼續使用 ptr2 就會出錯（或者當 ptr2 也 go out of scope 也會出錯）</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &lt;memory&gt;
int main()
{
    {
        // std::unique_ptr&lt;Entity&gt; e1 = new Entity();  不合法因為 unique_ptr 的 ctor 是 explicit
        std::unique_ptr&lt;Entity&gt; e1(new Entity());
        std::unique_ptr&lt;Entity&gt; e2 = std::make_unique&lt;Entity&gt;();
        // std::unique_ptr&lt;Entity&gt; e3 = e2;  不合法因為不能複製。unique_ptr 的 copy ctor 和 assignment 都被設成 delete 了
        e1-&gt;Print();
        e2-&gt;Print();
    }
}
</pre></div>
</div>
<ul class="simple">
<li><p>呼叫 Entity 成員的方式完全同 raw pointer</p></li>
<li><p>一出 scope 物件自動毀滅</p></li>
<li><p>用 make_unique 作初始化比較安全，處理了 constructor 出 exception 的情況</p></li>
<li><p>幾乎沒有 overhead</p></li>
</ul>
</li>
<li><p>shared_ptr：</p>
<ul class="simple">
<li><p>有一個 reference counting system 計算這個 ptr 被複製幾次，變成零的時候釋放記憶體</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &lt;memory&gt;
int main()
{
    {
        std::shared_ptr&lt;Entity&gt; e1(new Entity());  //是合法的但不要用。這樣比較慢
        {
            std::shared_ptr&lt;Entity&gt; e2 = std::make_shared&lt;Entity&gt;();
            std::weak_ptr&lt;Entity&gt; e3 = e1;
            e1 = e2;
        }// 內層
    }// 外層
}
</pre></div>
</div>
<ul class="simple">
<li><p>如果用 make_shared，reference counting 所需要的記憶體和 Entity instance 是一起配置的所以比較快</p></li>
<li><p>出內層的時候雖然 e2 死了，但物件還在，到離開外層的時候因為連 e1 都死了，物件才被消滅</p></li>
</ul>
</li>
<li><p>weak_ptr：</p>
<ul class="simple">
<li><p>和 shared_ptr 一起用。上面那段程式裡的 <code class="docutils literal notranslate"><span class="pre">e3</span> <span class="pre">=</span> <span class="pre">e1</span></code> 不會增加 reference count</p></li>
<li><p>不想 take ownership of entity 的時候用</p></li>
<li><p>可以透過 weak_ptr 問一個物件是否還活著，但 weak_ptr 不會 keep it alive</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="45.-Copying-and-Copy-Constructors-in-C++">
<h2>45. Copying and Copy Constructors in C++<a class="headerlink" href="#45.-Copying-and-Copy-Constructors-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="46.-The-Arrow-Operator-in-C++">
<h2>46. The Arrow Operator in C++<a class="headerlink" href="#46.-The-Arrow-Operator-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="47.-Dynamic-Arrays-in-C++-(std::vector)">
<h2>47. Dynamic Arrays in C++ (std::vector)<a class="headerlink" href="#47.-Dynamic-Arrays-in-C++-(std::vector)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="48.-Optimizing-the-usage-of-std::vector-in-C++">
<h2>48. Optimizing the usage of std::vector in C++<a class="headerlink" href="#48.-Optimizing-the-usage-of-std::vector-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="49.-Using-Libraries-in-C++-(Static-Linking)">
<h2>49. <a class="reference external" href="https://www.youtube.com/watch?v=or1dAmUO8k0&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=50&amp;t=0s">Using Libraries in C++ (Static Linking)</a><a class="headerlink" href="#49.-Using-Libraries-in-C++-(Static-Linking)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="50.-Using-Dynamic-Libraries-in-C++">
<h2>50. <a class="reference external" href="https://www.youtube.com/watch?v=pLy69V2F_8M&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=51&amp;t=0s">Using Dynamic Libraries in C++</a><a class="headerlink" href="#50.-Using-Dynamic-Libraries-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="51.-Making-and-Working-with-Libraries-in-C++-(Multiple-Projects-in-Visual-Studio)">
<h2>51. <a class="reference external" href="https://www.youtube.com/watch?v=Wt4dxDNmDA8&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=52&amp;t=0s">Making and Working with Libraries in C++ (Multiple Projects in Visual Studio)</a><a class="headerlink" href="#51.-Making-and-Working-with-Libraries-in-C++-(Multiple-Projects-in-Visual-Studio)" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>原來 GDA 是這樣設置的</p></li>
</ul>
</div>
<div class="section" id="52.-How-to-Deal-with-Multiple-Return-Values-in-C++">
<h2>52. How to Deal with Multiple Return Values in C++<a class="headerlink" href="#52.-How-to-Deal-with-Multiple-Return-Values-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="53.-Templates-in-C++">
<h2>53. <a class="reference external" href="https://www.youtube.com/watch?v=I-hZkUa9mIs&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=53">Templates in C++</a><a class="headerlink" href="#53.-Templates-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>叫 compiler 幫你寫 code（template will be compiled by your usage）</p></li>
<li><p>下面這個例子如果要改 Print 的定義就要改兩次</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Print</span><span class="p">(</span><span class="nb">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">void</span> <span class="n">Print</span><span class="p">(</span><span class="nb">float</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Print</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">Print</span><span class="p">(</span><span class="mf">5.5</span><span class="n">f</span><span class="p">);</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cin</span><span class="o">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>template 版定義：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">Print</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Print</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">Print</span><span class="p">(</span><span class="mf">5.5</span><span class="n">f</span><span class="p">);</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cin</span><span class="o">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>這個 Print 不是真正意義上的函數，而是一個 template。只有被呼叫到的時候才編譯，所以如果沒有被呼叫過，template 裡面就算有文法錯還是可以編譯</p></li>
<li><p>呼叫時可以 <code class="docutils literal notranslate"><span class="pre">Print&lt;int&gt;(5);</span></code> 也可以直接 <code class="docutils literal notranslate"><span class="pre">Print(5);</span></code>，編譯器會自己 infer</p></li>
<li><p>std::array template 的定義是像這樣：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="p">,</span> <span class="nb">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Array</span>
<span class="p">{</span>
<span class="n">private</span><span class="p">:</span>
    <span class="n">T</span> <span class="n">m_Array</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="n">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">GetSize</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">N</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Array</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">GetSize</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">end</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cin</span><span class="o">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>用 template 是在「program the compiler」，可以改到很複雜。有些公司直接禁用</p></li>
<li><p>The Cherno 認為不該全面禁用因為 template 還是很強大的。一個很好的應用是 logging system，因為可能想 log 的 type 有無限多種</p></li>
<li><p>但如果改到太複雜會很難 debug，只能紙筆寫下追蹤到底編譯了什麼 code</p></li>
</ul>
</div>
<div class="section" id="54.-Stack-vs-Heap-Memory-in-C++">
<h2>54. <a class="reference external" href="https://www.youtube.com/watch?v=wJ1L2nSIV1s&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=54">Stack vs Heap Memory in C++</a><a class="headerlink" href="#54.-Stack-vs-Heap-Memory-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://stackoverflow.com/questions/14588767/where-in-memory-are-my-variables-stored-in-c">C++ 程式開始執行時系統配置給該程式的記憶體會被分成五大區塊</a></p>
<ol class="arabic simple">
<li><p>Code Segment</p>
<ul>
<li><p>text, code, functions</p></li>
</ul>
</li>
<li><p>Uninitialized Data Segment</p></li>
<li><p>Initialized Data Segment</p>
<ul>
<li><p>static and global variables</p></li>
</ul>
</li>
<li><p>Stack Segment</p></li>
<li><p>Heap Segment</p></li>
</ol>
</li>
<li><p>Stack 跟 Heap 都是在記憶體裡，不會預設放在 CPU cache</p></li>
<li><p>Stack Based Memory：</p>
<ul>
<li><p>new 出來的記憶體空間就是 Heap based，其它都是 stack based</p></li>
<li><p>空間大小編譯時期就必需知道，這樣才能知道程式的 stack 區塊要預留多大</p></li>
<li><p>Stack based 記憶體只有在該變數的 scope 內才活著</p></li>
<li><p>Stack memory allocation 只是改 stack pointer（釋放記憶體也一樣），在 assembly 裡就是一個 mov，只有一個 CPU instruction，非常快！</p></li>
<li><p>Stack 裡所有變數都是擠在一起的，除了中間可能會被一些 safety guard</p></li>
<li><p><a class="reference external" href="https://youtu.be/wJ1L2nSIV1s?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=419">大部份 stack implementation 都是 grow the stack backward</a> 所以 VS 裡看到的記憶體內容是倒過來的</p></li>
</ul>
</li>
<li><p>Heap Based Memory：</p>
<ul>
<li><p>new 出來之後會一直活到被 delete</p></li>
<li><p>new 其實是呼叫 malloc，在執行期間去找目前能用且夠大的記憶體空間。系統預設會給一個程式一些 free list 空間，如果那些也不夠，程式就要另外向系統要多的空間，系統負責去找出夠大的空間配置給程式並聲明這塊空間被佔用了。很多 bookkeeping 要做，比 stack allocation（1 CPU instruction）慢很多</p></li>
</ul>
</li>
<li><p>當情況允許時應該盡量用 stack allocation</p></li>
<li><p><a class="reference external" href="https://youtu.be/wJ1L2nSIV1s?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=828">這裡</a>比較了兩種 allocation 的 assembly</p></li>
</ul>
</div>
<div class="section" id="55.-Macros-in-C++">
<h2>55. Macros in C++<a class="headerlink" href="#55.-Macros-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="56.-The-“auto”-keyword-in-C++">
<h2>56. The “auto” keyword in C++<a class="headerlink" href="#56.-The-“auto”-keyword-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="57.-Static-Arrays-in-C++-(std::array)">
<h2>57. Static Arrays in C++ (std::array)<a class="headerlink" href="#57.-Static-Arrays-in-C++-(std::array)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="58.-Function-Pointers-in-C++">
<h2>58. Function Pointers in C++<a class="headerlink" href="#58.-Function-Pointers-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="59.-Lambdas-in-C++">
<h2>59. Lambdas in C++<a class="headerlink" href="#59.-Lambdas-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="60.-Why-I-don’t-“using-namespace-std”">
<h2>60. Why I don’t “using namespace std”<a class="headerlink" href="#60.-Why-I-don’t-“using-namespace-std”" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="61.-Namespaces-in-C++">
<h2>61. Namespaces in C++<a class="headerlink" href="#61.-Namespaces-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="62.-Threads-in-C++">
<h2>62. Threads in C++<a class="headerlink" href="#62.-Threads-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="63.-Timing-in-C++">
<h2>63. Timing in C++<a class="headerlink" href="#63.-Timing-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="64.-Multidimensional-Arrays-in-C++-(2D-arrays)">
<h2>64. Multidimensional Arrays in C++ (2D arrays)<a class="headerlink" href="#64.-Multidimensional-Arrays-in-C++-(2D-arrays)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="65.-Sorting-in-C++">
<h2>65. Sorting in C++<a class="headerlink" href="#65.-Sorting-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="66.-Type-Punning-in-C++">
<h2>66. Type Punning in C++<a class="headerlink" href="#66.-Type-Punning-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="67.-Unions-in-C++">
<h2>67. Unions in C++<a class="headerlink" href="#67.-Unions-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="68.-Virtual-Destructors-in-C++">
<h2>68. Virtual Destructors in C++<a class="headerlink" href="#68.-Virtual-Destructors-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="69.-Casting-in-C++">
<h2>69. Casting in C++<a class="headerlink" href="#69.-Casting-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="70.-Conditional-and-Action-Breakpoints-in-C++">
<h2>70. Conditional and Action Breakpoints in C++<a class="headerlink" href="#70.-Conditional-and-Action-Breakpoints-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="71.-Safety-in-modern-C++-and-how-to-teach-it">
<h2>71. Safety in modern C++ and how to teach it<a class="headerlink" href="#71.-Safety-in-modern-C++-and-how-to-teach-it" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="72.-Precompiled-Headers-in-C++">
<h2>72. Precompiled Headers in C++<a class="headerlink" href="#72.-Precompiled-Headers-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="73.-Dynamic-Casting-in-C++">
<h2>73. Dynamic Casting in C++<a class="headerlink" href="#73.-Dynamic-Casting-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="74.-BENCHMARKING-in-C++-(how-to-measure-performance)">
<h2>74. BENCHMARKING in C++ (how to measure performance)<a class="headerlink" href="#74.-BENCHMARKING-in-C++-(how-to-measure-performance)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="75.-STRUCTURED-BINDINGS-in-C++">
<h2>75. STRUCTURED BINDINGS in C++<a class="headerlink" href="#75.-STRUCTURED-BINDINGS-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="76.-How-to-Deal-with-OPTIONAL-Data-in-C++">
<h2>76. How to Deal with OPTIONAL Data in C++<a class="headerlink" href="#76.-How-to-Deal-with-OPTIONAL-Data-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="77.-Multiple-TYPES-of-Data-in-a-SINGLE-VARIABLE-in-C++?">
<h2>77. Multiple TYPES of Data in a SINGLE VARIABLE in C++?<a class="headerlink" href="#77.-Multiple-TYPES-of-Data-in-a-SINGLE-VARIABLE-in-C++?" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="78.-How-to-store-ANY-data-in-C++">
<h2>78. How to store ANY data in C++<a class="headerlink" href="#78.-How-to-store-ANY-data-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="79.-How-to-make-C++-run-FASTER-(with-std::async)">
<h2>79. How to make C++ run FASTER (with std::async)<a class="headerlink" href="#79.-How-to-make-C++-run-FASTER-(with-std::async)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="80.-How-to-make-your-STRINGS-FASTER-in-C++!">
<h2>80. How to make your STRINGS FASTER in C++!<a class="headerlink" href="#80.-How-to-make-your-STRINGS-FASTER-in-C++!" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="81.-VISUAL-BENCHMARKING-in-C++-(how-to-measure-performance-visually)">
<h2>81. VISUAL BENCHMARKING in C++ (how to measure performance visually)<a class="headerlink" href="#81.-VISUAL-BENCHMARKING-in-C++-(how-to-measure-performance-visually)" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="82.-SINGLETONS-in-C++">
<h2>82. SINGLETONS in C++<a class="headerlink" href="#82.-SINGLETONS-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="83.-Small-String-Optimization-in-C++">
<h2>83. Small String Optimization in C++<a class="headerlink" href="#83.-Small-String-Optimization-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="84.-Track-MEMORY-ALLOCATIONS-the-Easy-Way-in-C++">
<h2>84. Track MEMORY ALLOCATIONS the Easy Way in C++<a class="headerlink" href="#84.-Track-MEMORY-ALLOCATIONS-the-Easy-Way-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="85.-lvalues-and-rvalues-in-C++">
<h2>85. <a class="reference external" href="https://youtu.be/fbYknr-HPYE?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=179">lvalues and rvalues in C++</a><a class="headerlink" href="#85.-lvalues-and-rvalues-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>在記憶體裡有位址的就是 lvalue，沒有的（temporary object）就是 rvalue，例如 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">10;</span></code> 裡 i 是 lvalue，10 是 rvalue</p></li>
<li><p>函數如果回傳暫存物件也是 rvalue，例如 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">GetValue();</span></code>，這裡 GetValue 是一個回傳整數 10 的函數</p></li>
<li><p>不能 assign 給 rvalue，例如 <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">=</span> <span class="pre">i;</span></code> 因為 temporary object 沒有記憶體位址沒辦法存 assign 進來的東西</p>
<ul>
<li><p>（所以左邊就一定是 lvalue？）</p></li>
<li><p>不一定在右邊就是 rvalue，例如可以 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">i;</span></code></p></li>
<li><p>如果 GetValue() 回傳 rvalue (如 int)，<code class="docutils literal notranslate"><span class="pre">GetValue()</span> <span class="pre">=</span> <span class="pre">5;</span></code> 編譯器會報錯 expression must be a modifiable (non-const) lvalue</p></li>
</ul>
</li>
<li><p>要讓 <code class="docutils literal notranslate"><span class="pre">GetValue()</span> <span class="pre">=</span> <span class="pre">5;</span></code> 合法需要回傳 lvalue ref</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span><span class="o">&amp;</span> <span class="n">GetValue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">static</span> <span class="nb">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>lvalue ref 不能接收 rvalue！！！lvalue ref 就是 lvalue 的別名，只能接收 lvalue</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="nb">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">){}</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">SetValue</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>    <span class="o">//</span> <span class="n">合法</span>
    <span class="n">SetValue</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>   <span class="o">//</span> <span class="n">不合法</span>
    <span class="n">SetValue</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">);</span>  <span class="o">//</span> <span class="n">不合法</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>但是！！有一個例外：const lvalue ref 可以接收 rvalue</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="nb">int</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="o">//</span> <span class="n">合法</span>
<span class="nb">int</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>        <span class="o">//</span> <span class="n">不合法</span>
</pre></div>
</div>
<ul class="simple">
<li><p>expression 像 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> 是 rvalue，所以上面的 <code class="docutils literal notranslate"><span class="pre">SetValue(i+j);</span></code> 不合法，但是用上面的例外把定義改成 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">SetValue(const</span> <span class="pre">int&amp;</span> <span class="pre">value){}</span></code> 就合法了</p>
<ul>
<li><p>所以 C++ 才會那麼多函數的輸入型別都是 const lvalue ref</p></li>
<li><p>這樣寫的好處是函數可以接收 lvalue 也可以接受 rvalue</p></li>
</ul>
</li>
<li><p>C++ 11 開始有只能接收 rvalue 的 rvalue ref <code class="docutils literal notranslate"><span class="pre">int&amp;&amp;</span> <span class="pre">value</span></code>（當對於只能接收 lvalue 的 (non-const) lvalue ref）：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="nb">int</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">){}</span>
<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">SetValue</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>    <span class="o">//</span> <span class="n">不合法</span>
    <span class="n">SetValue</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>   <span class="o">//</span> <span class="n">合法</span>
    <span class="n">SetValue</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">);</span>  <span class="o">//</span> <span class="n">合法</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>如果 overload（像下面這樣定義兩次），雖然 const lvalue ref 可以接收 rvalue，但傳入 rvalue 時還是會呼叫 rvalue ref 的版本</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="n">const</span> <span class="nb">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">){}</span>
<span class="n">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="nb">int</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">){}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="https://youtu.be/fbYknr-HPYE?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=692">使用 rvalue 的優點（會比較快？）</a></p>
<ul>
<li><p>例如上面的 <code class="docutils literal notranslate"><span class="pre">SetValue(i+j);</span></code> 不用為 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">j</span></code> 配置記憶體</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="86.-Continuous-Integration-in-C++">
<h2>86. Continuous Integration in C++<a class="headerlink" href="#86.-Continuous-Integration-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="87.-Static-Analysis-in-C++">
<h2>87. Static Analysis in C++<a class="headerlink" href="#87.-Static-Analysis-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="88.-Argument-Evaluation-Order-in-C++">
<h2>88. Argument Evaluation Order in C++<a class="headerlink" href="#88.-Argument-Evaluation-Order-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="89.-Move-Semantics-in-C++">
<h2>89. <a class="reference external" href="https://youtu.be/ehMg6zvXuMY?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=209">Move Semantics in C++</a><a class="headerlink" href="#89.-Move-Semantics-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>有兩種情況需要複製一個物件：</p>
<ul>
<li><p>return 一個物件時需要的 temp object：有 return value optimization 可以處理</p></li>
<li><p>把物件傳進函數裡，想要 take ownership 但不想要實際上 copy 時，其實應該用 move 才對</p></li>
</ul>
</li>
<li><p>下面這段程式因為 String 沒有 move ctor，執行會印出 <code class="docutils literal notranslate"><span class="pre">Created!</span> <span class="pre">Copied!</span> <span class="pre">Cherno</span></code>，String 的 ctor 和 copy ctor 加起來總共 new 了兩次記憶體，一次在 <code class="docutils literal notranslate"><span class="pre">String(&quot;Cherno&quot;)</span></code> 被構造出來的時候，一次是在它被傳進 e1 裡的時候 Entity 的 ctor 做了一次 copy。如果有 move ctor，<code class="docutils literal notranslate"><span class="pre">Entity</span> <span class="pre">e1(&quot;Cherno&quot;);</span></code> 就可以真正傳 rvalue 進到 Entity 裡，那個 copy 就可以省下來</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include&lt;iostream&gt;
class String
{
public:
    String() = default;
    String(const char* string)  // ctor
    {
        printf(&quot;Created!\n&quot;);
        m_Size = strlen(string);
        m_Data = new char[m_Size];
        memcpy(m_Data, string, m_Size);
    }
    String(const String&amp; other)  // copy ctor
    {
        printf(&quot;Copied!\n&quot;);
        m_Size = other.m_Size;
        m_Data = new char[m_Size];
        memcpy(m_Data, other.m_Data, m_Size);
    }
    ~String()
    {
        printf(&quot;Destroyed!\n&quot;)
        delete m_Data;
    }
    void Print()
    {
        for(uint32_t i= 1; i &lt; m_Size; i++)
            printf(&quot;%c&quot;, m_Data[i]);
        printf(&quot;\n&quot;);
    }
private:
    char* m_Data;
    uint32_t m_Size;
};
class Entity
{
public:
    Entity(const String&amp; name): m_Name(name){}
    void PrintName()
    {
        m_Name.Print();
    }
private:
    String m_Name;
}
int main():
{
    Entity e1(&quot;Cherno&quot;);  // 沒有 move，同 Entity e1(String(&quot;Cherno&quot;));
    e1.PrintName();
    std::cin.get();
}
</pre></div>
</div>
<ul>
<li><p>為了省下那次 copy，需要寫</p>
<ol class="arabic simple">
<li><p>可接收 rvalue 的 Entity ctor。下面這兩個做一樣的事情：把 input cast 成 rvalue。少了這個 cast 還是會呼叫到 String 的 ctor（實務上都是寫 <code class="docutils literal notranslate"><span class="pre">std::move</span></code> 而不會直接 cast）</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entity</span><span class="p">(</span><span class="n">String</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">):</span> <span class="n">m_Name</span><span class="p">((</span><span class="n">String</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="n">name</span><span class="p">){}</span>
<span class="n">Entity</span><span class="p">(</span><span class="n">String</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">):</span> <span class="n">m_Name</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)){}</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>String 的 move ctor。這裡只有 rewire 指標而已，沒有 new</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">String</span><span class="p">(</span><span class="n">String</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="n">noexcept</span>  <span class="o">//</span> <span class="n">move</span> <span class="n">ctor</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Moved!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">m_Size</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">m_Size</span><span class="p">;</span>
    <span class="n">m_Data</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">m_Data</span><span class="p">;</span>
    <span class="n">other</span><span class="o">.</span><span class="n">m_Size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">other</span><span class="o">.</span><span class="n">m_Data</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p><cite>為什麼需要 ``other.m_Data = nullptr;`</cite>？ &lt;<a class="reference external" href="https://youtu.be/ehMg6zvXuMY?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=600">https://youtu.be/ehMg6zvXuMY?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=600</a>&gt;`__因為傳進 Entity 裡的 rvalue String 在毀滅的時候一樣會呼叫 dtor，如果沒有在 move ctor 裡把 other 設成 hollow object，當 move 完成的時候 other 和 m_Data 會指著同一塊記憶體，而這塊記憶體馬上就被 rvalue String（在這個例子裡是傳進 Entity ctor 裡的 <code class="docutils literal notranslate"><span class="pre">String&amp;&amp;</span> <span class="pre">name</span></code>）呼叫的 dtor delete 掉了</p></li>
</ul>
</div>
<div class="section" id="90.-std::move-and-the-Move-Assignment-Operator-in-C++">
<h2>90. <a class="reference external" href="https://youtu.be/OWNeCTd7yQE?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=146">std::move and the Move Assignment Operator in C++</a><a class="headerlink" href="#90.-std::move-and-the-Move-Assignment-Operator-in-C++" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>用上面的例子，這兩行 code 會呼叫 copy ctor：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">String</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">string</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>如果想讓它呼叫 move ctor 而不是 copy，可以用下面任意一種：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="n">String</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="n">string</span><span class="p">;</span>
<span class="n">String</span> <span class="n">dest</span><span class="p">((</span><span class="n">String</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="n">string</span><span class="p">);</span>
<span class="n">String</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
<span class="n">String</span> <span class="n">dest</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">string</span><span class="p">));</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::move</span></code> 做的事就是把傳進來的物件 cast 成 rvalue。如果要 move 一個已經是 rvalue 的物件，就不需要 <code class="docutils literal notranslate"><span class="pre">std::move</span></code>。如果要 move 的一個新構造的物件，也可以不用 <code class="docutils literal notranslate"><span class="pre">std::move</span></code> 因為 ctor 本來也就會耗資源。但如果是一個已經存在的 lvalue 物件，用 <code class="docutils literal notranslate"><span class="pre">std::move</span></code> 可以省下 copy 造成的額外負擔</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::move</span></code> 比直接 cast 好因為</p>
<ul>
<li><p><a class="reference external" href="https://youtu.be/OWNeCTd7yQE?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;t=306">有些情況下</a> cast 會失敗</p></li>
<li><p>增加 code 可讀性</p></li>
</ul>
</li>
<li><p>以上所有 dest 都是新宣告的，所以呼叫 move ctor。如果 dest 已經存在，就需要 move assignment：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">dest1</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>  <span class="o">//</span> <span class="n">呼叫</span> <span class="n">move</span> <span class="n">ctor</span>
<span class="n">String</span> <span class="n">dest2</span><span class="p">;</span>
<span class="n">dest2</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>         <span class="o">//</span> <span class="n">呼叫</span> <span class="n">move</span> <span class="n">assignment</span>
</pre></div>
</div>
<ul class="simple">
<li><p>move assignment：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">String</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">String</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="n">noexcept</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Moved!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">delete</span><span class="p">[]</span> <span class="n">m_Data</span><span class="p">;</span>
        <span class="n">m_Size</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">m_Size</span><span class="p">;</span>
        <span class="n">m_Data</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">m_Data</span><span class="p">;</span>
        <span class="n">other</span><span class="o">.</span><span class="n">m_Size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">other</span><span class="o">.</span><span class="n">m_Data</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>和 move ctor 有三處不同：</p>
<ul>
<li><p>以 ref 的型式回傳自己（<a href="#id1"><span class="problematic" id="id2">*</span></a>this）</p></li>
<li><p>需要 <code class="docutils literal notranslate"><span class="pre">delete[]</span> <span class="pre">m_Data;</span></code> 因為 move ssign 之後原本的 data 就不需要了，新的 m_Data 指標被指向新的 data，如果不先 delete 舊的 data 會有 memory leaking</p></li>
<li><p>檢查 <code class="docutils literal notranslate"><span class="pre">this</span> <span class="pre">!=</span> <span class="pre">&amp;other</span></code> 是為了防止有人呼叫 <code class="docutils literal notranslate"><span class="pre">dest</span> <span class="pre">=</span> <span class="pre">std::move(dest);</span></code>（把自己傳給自己）</p></li>
</ul>
</li>
<li><p>下面這段 code 在 move 之前 dest 是空的，move 完之後變成 apple 是空的：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">String</span> <span class="n">apple</span> <span class="o">=</span> <span class="s2">&quot;Apple&quot;</span><span class="p">;</span>
<span class="n">String</span> <span class="n">dest</span><span class="p">;</span>
<span class="n">dest</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">apple</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>所以現在 C++ 物件必寫函數從四個變成六個：</p>
<ul>
<li><p>ctor</p></li>
<li><p>dtor</p></li>
<li><p>copy ctor</p></li>
<li><p>copy assignment</p></li>
<li><p>move ctor</p></li>
<li><p>move assignment</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/rule_of_three">Rule of three/five/zero</a></p>
<ul>
<li><p>3: 如果需要下列三者之一，幾乎可以肯定三者同時需要：custom dtor，copy ctor，copy assignment</p></li>
<li><p>5: 需要 move semantics 的 class 要另外寫 move ctor 和 move assignment</p></li>
<li><p>0: 如果一個 class 沒有 ownership 的概念，應該上面五個都不要寫（單一職掌原則）</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="91.-ARRAY---Making-DATA-STRUCTURES-in-C++">
<h2>91. ARRAY - Making DATA STRUCTURES in C++<a class="headerlink" href="#91.-ARRAY---Making-DATA-STRUCTURES-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="92.-VECTOR/DYNAMIC-ARRAY---Making-DATA-STRUCTURES-in-C++">
<h2>92. VECTOR/DYNAMIC ARRAY - Making DATA STRUCTURES in C++<a class="headerlink" href="#92.-VECTOR/DYNAMIC-ARRAY---Making-DATA-STRUCTURES-in-C++" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="DS%20and%20Algo.html" class="btn btn-neutral float-right" title="DS and Algo" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="C%2B%2B.html" class="btn btn-neutral float-left" title="&lt;no title&gt;" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, beginnerSC

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>